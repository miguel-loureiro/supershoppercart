package com.supershoppercart.services;

import com.google.api.core.ApiFuture;
import com.google.cloud.firestore.*;
import com.supershoppercart.dtos.ShopCartDetailDTO;
import com.supershoppercart.dtos.ShopperSummaryDTO;
import com.supershoppercart.enums.SharePermission;
import com.supershoppercart.models.ShopCart;
import com.supershoppercart.models.Shopper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.concurrent.ExecutionException;

@Service
public class FirestoreService {

    private static final Logger logger = LoggerFactory.getLogger(FirestoreService.class);

    private final Firestore firestore;

    @Autowired
    public FirestoreService(Firestore firestore) {
        this.firestore = firestore;
    }

    /**
     * Saves a Shopper object to Firestore. If the shopper's ID is provided,
     * it will be used as the document ID. If the shopper ID is null or empty,
     * an IllegalArgumentException will be thrown.
     *
     * @param shopper The Shopper object to save.
     * @return The ID of the saved shopper document.
     * @throws IllegalArgumentException if the shopper ID is null or empty.
     * @throws RuntimeException if there's an error during Firestore operation.
     */
    public String saveShopper(Shopper shopper) {
        if (shopper == null || shopper.getId() == null || shopper.getId().trim().isEmpty()) {
            throw new IllegalArgumentException("Shopper ID cannot be null or empty when saving a shopper.");
        }
        try {
            CollectionReference shoppersCollection = firestore.collection("shoppers");
            DocumentReference docRef = shoppersCollection.document(shopper.getId());
            docRef.set(shopper).get();
            return docRef.getId();
        } catch (InterruptedException | ExecutionException e) {
            throw new RuntimeException("Error saving shopper: " + e.getMessage(), e);
        }
    }

    /**
     * Saves a ShopCart object to Firestore. A new document ID will be generated by Firestore.
     *
     * @param shopCart The ShopCart object to save.
     * @return The newly generated ID of the saved shop cart document.
     * @throws RuntimeException if there's an error during Firestore operation.
     */
    public String saveShopCart(ShopCart shopCart) {
        try {
            // Give all initial shoppers a default EDIT permission
            if (shopCart.getShopperIds() != null) {

                logger.info("Saving ShopCart with ID {} to project {}",
                        shopCart.getId(),
                        firestore.getOptions().getProjectId());
                for (String shopperId : shopCart.getShopperIds()) {
                    shopCart.addOrUpdatePermission(shopperId, SharePermission.EDIT);
                }
            }
            // The creator should always have ADMIN permission
            if (shopCart.getCreatedBy() != null) {
                shopCart.addOrUpdatePermission(shopCart.getCreatedBy(), SharePermission.ADMIN);
            }

            CollectionReference shopcartsCollection = firestore.collection("shopcarts");
            DocumentReference docRef = shopcartsCollection.document(shopCart.getId()); // Use the ID from the object
            docRef.set(shopCart).get(); // Use set() to save the object at that specific ID

            return docRef.getId();

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt(); // preserve thread state
            throw new RuntimeException("Interrupted while saving shop cart", e);
        } catch (ExecutionException e) {
            logger.error("Execution error while saving shop cart: {}", e.getCause() != null ? e.getCause().getMessage() : e.getMessage(), e);
            throw new RuntimeException("Execution error while saving shop cart", e.getCause());
        }
    }

    /**
     * Retrieves a list of ShopCartDTOs associated with a specific shopper ID.
     * The results are ordered by creation time in descending order.
     *
     * @param shopperId The ID of the shopper whose carts are to be retrieved.
     * @return A list of ShopCartDTOs, or an empty list if no carts are found.
     * @throws IllegalArgumentException if the shopper ID is null or empty.
     * @throws RuntimeException if there's an error during Firestore operation.
     */
    public List<ShopCartDetailDTO> getShopCartsByShopperId(String shopperId) {
        if (shopperId == null || shopperId.trim().isEmpty()) {
            throw new IllegalArgumentException("Shopper ID cannot be null or empty when getting shop carts.");
        }
        try {
            QuerySnapshot snapshot = firestore.collection("shopcarts")
                    .whereArrayContains("shopperIds", shopperId)
                    .orderBy("createdAt", Query.Direction.DESCENDING)
                    .get()
                    .get();

            List<ShopCartDetailDTO> shopCartDetailDTOS = new ArrayList<>();
            for (DocumentSnapshot doc : snapshot.getDocuments()) {
                ShopCart shopCart = doc.toObject(ShopCart.class);
                if (shopCart != null) {
                    // Fetch full Shopper objects based on shopperIds stored in the ShopCart
                    List<Shopper> associatedShoppers = fetchShoppersByIds(shopCart.getShopperIds());
                    // Convert List<Shopper> to List<ShopperSummaryDTO>
                    List<ShopperSummaryDTO> shopperSummaries = associatedShoppers.stream()
                            .map(ShopperSummaryDTO::new)
                            .toList();

                    ShopCartDetailDTO dto = new ShopCartDetailDTO(doc.getId(), shopCart);
                    dto.setShoppers(shopperSummaries); // Set the fetched Shopper objects in the DTO
                    shopCartDetailDTOS.add(dto);
                }
            }
            return shopCartDetailDTOS;
        } catch (InterruptedException | ExecutionException e) {
            logger.error("Error getting shop carts by shopper ID: {}", e.getMessage(), e);
            throw new RuntimeException("Error getting shop carts by shopper ID: " + e.getMessage(), e);
        }
    }

    /**
     * Retrieves a single ShopCartDTO by its document ID.
     *
     * @param cartId The ID of the shop cart document to retrieve.
     * @return The ShopCartDTO if found, otherwise null.
     * @throws IllegalArgumentException if the cart ID is null or empty.
     * @throws RuntimeException if there's an error during Firestore operation.
     */
    public ShopCartDetailDTO getShopCartById(String cartId) {
        if (cartId == null || cartId.trim().isEmpty()) {
            throw new IllegalArgumentException("Cart ID cannot be null or empty when getting a shop cart by ID.");
        }
        try {
            DocumentReference docRef = firestore.collection("shopcarts").document(cartId);
            DocumentSnapshot doc = docRef.get().get();

            if (doc.exists()) {
                ShopCart shopCart = doc.toObject(ShopCart.class);
                if (shopCart != null) {
                    // Fetch full Shopper objects based on shopperIds stored in the ShopCart
                    List<Shopper> associatedShoppers = fetchShoppersByIds(shopCart.getShopperIds());
                    // Convert List<Shopper> to List<ShopperSummaryDTO>
                    List<ShopperSummaryDTO> shopperSummaries = associatedShoppers.stream()
                            .map(ShopperSummaryDTO::new)
                            .toList();

                    ShopCartDetailDTO dto = new ShopCartDetailDTO(doc.getId(), shopCart);
                    dto.setShoppers(shopperSummaries); // Set the fetched Shopper objects in the DTO
                    return dto;
                }
            }
            return null;
        } catch (InterruptedException | ExecutionException e) {
            logger.error("Error getting shop cart by ID: {}", e.getMessage(), e);
            throw new RuntimeException("Error getting shop cart by ID: " + e.getMessage(), e);
        }
    }

    /**
     * Helper method to fetch Shopper objects given a list of their IDs.
     *
     * @param shopperIds A list of shopper IDs.
     * @return A list of Shopper objects. Returns an empty list if input is null or empty,
     * or if no shoppers are found for the given IDs.
     * @throws RuntimeException if there's an error during Firestore operation.
     */
    List<Shopper> fetchShoppersByIds(List<String> shopperIds) {
        if (shopperIds == null || shopperIds.isEmpty()) {
            return new ArrayList<>();
        }

        List<Shopper> shoppers = new ArrayList<>();
        try {
            // Firestore 'in' query supports a maximum of 10 values.
            // For lists larger than 10, we must split them into batches.
            if (shopperIds.size() > 10) {
                // Split the list of IDs into sub-lists of size 10
                for (int i = 0; i < shopperIds.size(); i += 10) {
                    int end = Math.min(shopperIds.size(), i + 10);
                    List<String> batchIds = shopperIds.subList(i, end);

                    // Execute a 'whereIn' query for the current batch
                    QuerySnapshot snapshot = firestore.collection("shoppers")
                            .whereIn(FieldPath.documentId(), batchIds)
                            .get()
                            .get();

                    // Add the results to the main list
                    for (DocumentSnapshot doc : snapshot.getDocuments()) {
                        Shopper shopper = doc.toObject(Shopper.class);
                        if (shopper != null) {
                            shoppers.add(shopper);
                        }
                    }
                }
            } else {
                // For 10 or fewer IDs, a single 'whereIn' query is sufficient and efficient.
                QuerySnapshot snapshot = firestore.collection("shoppers")
                        .whereIn(FieldPath.documentId(), shopperIds)
                        .get()
                        .get();
                for (DocumentSnapshot doc : snapshot.getDocuments()) {
                    Shopper shopper = doc.toObject(Shopper.class);
                    if (shopper != null) {
                        shoppers.add(shopper);
                    }
                }
            }
        } catch (InterruptedException | ExecutionException e) {
            logger.error("Error fetching shoppers using 'whereIn' query: {}", e.getMessage(), e);
            throw new RuntimeException("Error fetching associated shoppers: " + e.getMessage(), e);
        }
        return shoppers;
    }

    // Cart sharing methods ----------------------------------------------------------------------------------

    /**
     * Shares a cart with another shopper by email
     */
    public boolean shareCartWithShopper(String cartId, String requesterShopperId, String targetEmail, SharePermission permission) {
        if (cartId == null || requesterShopperId == null || targetEmail == null || permission == null) {
            throw new IllegalArgumentException("All parameters are required for sharing a cart");
        }

        try {
            // 1. Get the cart and verify permissions
            DocumentReference cartRef = firestore.collection("shopcarts").document(cartId);
            DocumentSnapshot cartDoc = cartRef.get().get();

            if (!cartDoc.exists()) {
                logger.warn("Cart not found: {}", cartId);
                return false;
            }

            ShopCart cart = cartDoc.toObject(ShopCart.class);
            if (!canShareCart(cart, requesterShopperId)) {
                logger.warn("Shopper {} does not have permission to share cart {}", requesterShopperId, cartId);
                return false;
            }

            // 2. Find target shopper by email
            Shopper targetShopper = findShopperByEmail(targetEmail);
            if (targetShopper == null) {
                logger.warn("Target shopper not found with email: {}", targetEmail);
                return false;
            }

            // 3. Update cart with new sharing permission
            cart.addOrUpdatePermission(targetShopper.getId(), permission);

            // 4. Add target shopper to shopperIds if not already present
            List<String> shopperIds = cart.getShopperIds();
            if (!shopperIds.contains(targetShopper.getId())) {
                shopperIds.add(targetShopper.getId());
            }

            // 5. Update the cart in Firestore
            Map<String, Object> updates = new HashMap<>();
            updates.put("sharePermissions", cart.getSharePermissions());
            updates.put("shopperIds", shopperIds);
            updates.put("lastModified", FieldValue.serverTimestamp());

            cartRef.update(updates).get();

            logger.info("Cart {} successfully shared with shopper {} ({})", cartId, targetShopper.getId(), targetEmail);
            return true;

        } catch (InterruptedException | ExecutionException e) {
            logger.error("Error sharing cart: {}", e.getMessage(), e);
            throw new RuntimeException("Error sharing cart: " + e.getMessage(), e);
        }
    }

    /**
     * Removes sharing permission for a shopper
     */
    public boolean removeCartSharing(String cartId, String requesterShopperId, String targetShopperId) {
        try {
            DocumentReference cartRef = firestore.collection("shopcarts").document(cartId);
            DocumentSnapshot cartDoc = cartRef.get().get();

            if (!cartDoc.exists()) {
                return false;
            }

            ShopCart cart = cartDoc.toObject(ShopCart.class);
            if (!canShareCart(cart, requesterShopperId)) {
                return false;
            }

            // Remove from permissions and shopperIds
            cart.removePermission(targetShopperId);
            List<String> shopperIds = cart.getShopperIds();
            shopperIds.remove(targetShopperId);

            Map<String, Object> updates = new HashMap<>();
            updates.put("sharePermissions", cart.getSharePermissions());
            updates.put("shopperIds", shopperIds);
            updates.put("lastModified", FieldValue.serverTimestamp());

            cartRef.update(updates).get();
            return true;

        } catch (InterruptedException | ExecutionException e) {
            logger.error("Error removing cart sharing: {}", e.getMessage(), e);
            throw new RuntimeException("Error removing cart sharing: " + e.getMessage(), e);
        }
    }

    /**
     * Checks if a shopper can share a specific cart
     */
    boolean canShareCart(ShopCart cart, String shopperId) {
        // Cart creator can always share
        if (shopperId.equals(cart.getCreatedBy())) {
            return true;
        }

        // Check if shopper has ADMIN permission
        SharePermission permission = cart.getPermissionForShopper(shopperId);
        return permission == SharePermission.ADMIN;
    }

    /**
     * Checks if a shopper can edit a specific cart
     */
    public boolean canEditCart(ShopCart cart, String shopperId) {
        // Cart creator can always edit
        if (shopperId.equals(cart.getCreatedBy())) {
            return true;
        }

        // Check permissions
        SharePermission permission = cart.getPermissionForShopper(shopperId);
        return permission == SharePermission.EDIT || permission == SharePermission.ADMIN;
    }

    /**
     * Finds a shopper by email address
     */
    Shopper findShopperByEmail(String email) {
        try {
            QuerySnapshot snapshot = firestore.collection("shoppers")
                    .whereEqualTo("email", email)
                    .limit(1)
                    .get()
                    .get();

            if (!snapshot.isEmpty()) {
                return snapshot.getDocuments().get(0).toObject(Shopper.class);
            }
            return null;

        } catch (InterruptedException | ExecutionException e) {
            logger.error("Error finding shopper by email: {}", e.getMessage(), e);
            throw new RuntimeException("Error finding shopper by email: " + e.getMessage(), e);
        }
    }

    /**
     * Enhanced method to save shop cart with creator information
     */
    public String saveShopCartWithCreator(ShopCart shopCart, String creatorId) {

        shopCart.setId(UUID.randomUUID().toString());
        shopCart.setCreatedBy(creatorId);

        // Ensure creator is in shopperIds
        if (!shopCart.getShopperIds().contains(creatorId)) {
            shopCart.getShopperIds().add(creatorId);
        }

        // Initialize permissions list if null
        if (shopCart.getSharePermissions() == null) {
            shopCart.setSharePermissions(new ArrayList<>());
        }

        return saveShopCart(shopCart);
    }

    /**
     * Private helper to convert a ShopCart document into a fully populated DTO,
     * including fetching and attaching all associated shopper details.
     */
    ShopCartDetailDTO hydrateShopCartDTO(DocumentSnapshot cartDoc) throws Exception {
        ShopCart cart = cartDoc.toObject(ShopCart.class);
        if (cart == null) return null;

        ShopCartDetailDTO dto = new ShopCartDetailDTO(cartDoc.getId(), cart);

        // Hydration Step: Fetch all shoppers in one go
        if (cart.getShopperIds() != null && !cart.getShopperIds().isEmpty()) {
            Query shoppersQuery = firestore.collection("shoppers").whereIn(FieldPath.documentId(), cart.getShopperIds());
            ApiFuture<QuerySnapshot> shoppersFuture = shoppersQuery.get();
            List<ShopperSummaryDTO> shopperDTOs = new ArrayList<>();
            for (DocumentSnapshot shopperDoc : shoppersFuture.get().getDocuments()) {
                Shopper shopper = shopperDoc.toObject(Shopper.class);
                if (shopper != null) {
                    shopperDTOs.add(new ShopperSummaryDTO(shopper));
                }
            }
            dto.setShoppers(shopperDTOs);
        }
        return dto;
    }
}